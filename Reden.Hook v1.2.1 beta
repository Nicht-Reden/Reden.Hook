local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Window = Library:CreateWindow({
    Title = 'Reden.Hook',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Combat = Window:AddTab('Combat'),
    Visuals = Window:AddTab('Visuals'),
    StreamProtection = Window:AddTab('Stream Protection'),
    Settings = Window:AddTab('Settings'),
}

local VisualsGroup = Tabs.Visuals:AddRightGroupbox('Visuals')

local crosshairEnabled = false
local crosshairSpinSpeed = 3.5
local crosshairText = "Reden.Hook"
local crosshairColor = Color3.fromRGB(255, 255, 255)
local crosshairSize = 27.8
local crosshairThickness = 2.3
local crosshairGap = 8.9
local outlineThickness = 2
local centerDotEnabled = true
local textOffsetY = 20
local crosshairOffsetX = 0
local crosshairOffsetY = -29.3
local rainbowMode = false
local rainbowSpeed = 2.2
local crosshairGui = nil
local spinConnection = nil
local rainbowConnection = nil

local fullbrightEnabled = false
local lightColorEnabled = false
local lightColor = Color3.fromRGB(135, 206, 235)
local originalLighting = {}

local autoCrouchEnabled = false
local crouchTime = 1 
local beforeRepeatDelay = 0.5 
local isAutoCrouching = false

local speedHackEnabled = false
local speedMultiplier = 2.5
local speedConnection = nil
local speedRandomization = true
local speedVariance = 0.1

local keybindListEnabled = false
local keybindListAlwaysShow = true
local keybindListGui = nil
local keybindUpdateConnection = nil
local keybindCache = {}
local keybindDragging = false
local keybindDragStart = nil
local keybindStartPos = nil

local espEnabled = false
local espBoxEnabled = true
local espNameEnabled = true
local espHealthEnabled = true
local espDistanceEnabled = true
local espTeamCheck = true
local espBoxColor = Color3.fromRGB(255, 255, 255)
local espNameColor = Color3.fromRGB(255, 255, 255)
local espHealthColor = Color3.fromRGB(0, 255, 0)
local espBoxThickness = 1
local espTextSize = 13
local espMaxDistance = 1000
local espRainbow = false
local espConnection = nil
local espObjects = {}
local espUpdateRate = 0.01
local espLastUpdate = 0
local espTeamColor = true
local espFillBox = false
local espFillTransparency = 0.1

local aimbotEnabled = false
local aimbotFOV = 150
local aimbotSmoothing = 0.15
local aimbotVisibleCheck = true
local aimbotTeamCheck = true
local aimbotTargetPart = "Head"
local aimbotPrediction = false
local aimbotPredictionAmount = 0.13
local aimbotConnection = nil
local fovCircle = nil
local showFOV = true
local fovColor = Color3.fromRGB(255, 255, 255)
local fovTransparency = 0.5
local aimbotMouseButton = "Right"
local aimbotStickiness = 0.8
local aimbotMaxDistance = 500
local aimbotIgnoreDistance = false

local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera

local function getRainbowColor(offset)
    local hue = (tick() * rainbowSpeed * 0.5 + (offset or 0)) % 1
    return Color3.fromHSV(hue, 1, 1)
end

local function getRandomSpeedVariance()
    if speedRandomization then
        return (math.random() * speedVariance * 2) - speedVariance
    end
    return 0
end

local function createESP(player)
    if espObjects[player] then
        return
    end
    
    local drawings = {
        box = Drawing.new("Square"),
        boxFill = Drawing.new("Square"),
        name = Drawing.new("Text"),
        health = Drawing.new("Text"),
        distance = Drawing.new("Text"),
        healthBar = Drawing.new("Square"),
        healthBarOutline = Drawing.new("Square")
    }
    
    drawings.box.Thickness = espBoxThickness
    drawings.box.Filled = false
    drawings.box.Color = espBoxColor
    drawings.box.Visible = false
    drawings.box.ZIndex = 2
    
    drawings.boxFill.Filled = true
    drawings.boxFill.Color = espBoxColor
    drawings.boxFill.Transparency = espFillTransparency
    drawings.boxFill.Visible = false
    drawings.boxFill.ZIndex = 1
    
    drawings.name.Size = espTextSize
    drawings.name.Color = espNameColor
    drawings.name.Center = true
    drawings.name.Outline = true
    drawings.name.Visible = false
    drawings.name.ZIndex = 3
    drawings.name.Font = 2
    
    drawings.health.Size = espTextSize - 1
    drawings.health.Color = espHealthColor
    drawings.health.Center = true
    drawings.health.Outline = true
    drawings.health.Visible = false
    drawings.health.ZIndex = 3
    drawings.health.Font = 2
    
    drawings.distance.Size = espTextSize - 2
    drawings.distance.Color = Color3.fromRGB(200, 200, 200)
    drawings.distance.Center = true
    drawings.distance.Outline = true
    drawings.distance.Visible = false
    drawings.distance.ZIndex = 3
    drawings.distance.Font = 2
    
    drawings.healthBarOutline.Thickness = 1
    drawings.healthBarOutline.Filled = true
    drawings.healthBarOutline.Color = Color3.fromRGB(0, 0, 0)
    drawings.healthBarOutline.Visible = false
    drawings.healthBarOutline.ZIndex = 2
    
    drawings.healthBar.Filled = true
    drawings.healthBar.Color = Color3.fromRGB(0, 255, 0)
    drawings.healthBar.Visible = false
    drawings.healthBar.ZIndex = 3
    
    espObjects[player] = drawings
end

local function removeESP(player)
    local drawings = espObjects[player]
    if drawings then
        for _, drawing in pairs(drawings) do
            drawing:Remove()
        end
        espObjects[player] = nil
    end
end

local function getHealthColor(health, maxHealth)
    local percentage = health / maxHealth
    if percentage > 0.75 then
        return Color3.fromRGB(0, 255, 0)
    elseif percentage > 0.5 then
        return Color3.fromRGB(255, 255, 0)
    elseif percentage > 0.25 then
        return Color3.fromRGB(255, 165, 0)
    else
        return Color3.fromRGB(255, 0, 0)
    end
end

local function updateESP()
    if not espEnabled then return end
    
    local currentTime = tick()
    if currentTime - espLastUpdate < espUpdateRate then
        return
    end
    espLastUpdate = currentTime
    
    for player, drawings in pairs(espObjects) do
        local success = pcall(function()
            if not player or not player.Parent or player == LocalPlayer then
                for _, drawing in pairs(drawings) do
                    drawing.Visible = false
                end
                return
            end
            
            if espTeamCheck and player.Team == LocalPlayer.Team then
                for _, drawing in pairs(drawings) do
                    drawing.Visible = false
                end
                return
            end
            
            local character = player.Character
            if not character then
                for _, drawing in pairs(drawings) do
                    drawing.Visible = false
                end
                return
            end
            
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            local rootPart = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso")
            
            if not humanoid or not rootPart or humanoid.Health <= 0 then
                for _, drawing in pairs(drawings) do
                    drawing.Visible = false
                end
                return
            end
            
            local distance = (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")) and
                (LocalPlayer.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude or math.huge
            
            if distance > espMaxDistance then
                for _, drawing in pairs(drawings) do
                    drawing.Visible = false
                end
                return
            end
            
            local head = character:FindFirstChild("Head")
            if not head then
                for _, drawing in pairs(drawings) do
                    drawing.Visible = false
                end
                return
            end
            
            local headPos = head.Position + Vector3.new(0, head.Size.Y / 2, 0)
            local legPos = rootPart.Position - Vector3.new(0, rootPart.Size.Y + 1, 0)
            
            local headScreen, headOnScreen = Camera:WorldToViewportPoint(headPos)
            local legScreen, legOnScreen = Camera:WorldToViewportPoint(legPos)
            
            if not headOnScreen and not legOnScreen then
                for _, drawing in pairs(drawings) do
                    drawing.Visible = false
                end
                return
            end
            
            local height = math.abs(headScreen.Y - legScreen.Y)
            local width = height / 2
            local boxX = (headScreen.X + legScreen.X) / 2 - width / 2
            local boxY = math.min(headScreen.Y, legScreen.Y)
            
            local boxColor = espBoxColor
            if espRainbow then
                boxColor = getRainbowColor(player.UserId % 10)
            elseif espTeamColor and player.Team then
                boxColor = player.Team.TeamColor.Color
            end
            
            if espBoxEnabled then
                drawings.box.Size = Vector2.new(width, height)
                drawings.box.Position = Vector2.new(boxX, boxY)
                drawings.box.Color = boxColor
                drawings.box.Thickness = espBoxThickness
                drawings.box.Visible = true
                
                if espFillBox then
                    drawings.boxFill.Size = Vector2.new(width, height)
                    drawings.boxFill.Position = Vector2.new(boxX, boxY)
                    drawings.boxFill.Color = boxColor
                    drawings.boxFill.Transparency = espFillTransparency
                    drawings.boxFill.Visible = true
                else
                    drawings.boxFill.Visible = false
                end
            else
                drawings.box.Visible = false
                drawings.boxFill.Visible = false
            end
            
            if espNameEnabled then
                local displayName = player.DisplayName
                if #displayName > 15 then
                    displayName = displayName:sub(1, 15) .. "..."
                end
                drawings.name.Text = displayName
                drawings.name.Position = Vector2.new(boxX + width / 2, boxY - 16)
                drawings.name.Color = espRainbow and getRainbowColor(player.UserId % 10) or espNameColor
                drawings.name.Size = espTextSize
                drawings.name.Visible = true
            else
                drawings.name.Visible = false
            end
            
            if espHealthEnabled then
                local health = math.floor(humanoid.Health)
                local maxHealth = math.floor(humanoid.MaxHealth)
                drawings.health.Text = tostring(health) .. " HP"
                drawings.health.Position = Vector2.new(boxX + width / 2, boxY + height + 2)
                drawings.health.Color = getHealthColor(health, maxHealth)
                drawings.health.Size = espTextSize - 1
                drawings.health.Visible = true
                
                local healthBarWidth = 3
                local healthBarHeight = height * (health / maxHealth)
                
                drawings.healthBarOutline.Size = Vector2.new(healthBarWidth + 2, height + 2)
                drawings.healthBarOutline.Position = Vector2.new(boxX - healthBarWidth - 3, boxY - 1)
                drawings.healthBarOutline.Visible = true
                
                drawings.healthBar.Size = Vector2.new(healthBarWidth, healthBarHeight)
                drawings.healthBar.Position = Vector2.new(boxX - healthBarWidth - 2, boxY + height - healthBarHeight)
                drawings.healthBar.Color = getHealthColor(health, maxHealth)
                drawings.healthBar.Visible = true
            else
                drawings.health.Visible = false
                drawings.healthBar.Visible = false
                drawings.healthBarOutline.Visible = false
            end
            
            if espDistanceEnabled then
                drawings.distance.Text = math.floor(distance) .. "m"
                drawings.distance.Position = Vector2.new(boxX + width / 2, boxY + height + 18)
                drawings.distance.Size = espTextSize - 2
                drawings.distance.Visible = true
            else
                drawings.distance.Visible = false
            end
            
        end)
        
        if not success then
            for _, drawing in pairs(drawings) do
                drawing.Visible = false
            end
        end
    end
end

local function startESP()
    for player, _ in pairs(espObjects) do
        removeESP(player)
    end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            createESP(player)
        end
    end
    
    Players.PlayerAdded:Connect(function(player)
        if espEnabled and player ~= LocalPlayer then
            task.wait(0.1)
            createESP(player)
        end
    end)
    
    Players.PlayerRemoving:Connect(function(player)
        removeESP(player)
    end)
    
    if espConnection then
        espConnection:Disconnect()
    end
    
    espConnection = RunService.RenderStepped:Connect(updateESP)
end

local function stopESP()
    if espConnection then
        espConnection:Disconnect()
        espConnection = nil
    end
    
    for player, _ in pairs(espObjects) do
        removeESP(player)
    end
end

local function createFOVCircle()
    if fovCircle then
        fovCircle:Remove()
        fovCircle = nil
    end
    
    if not showFOV then return end
    
    local circle = Drawing.new("Circle")
    circle.Transparency = fovTransparency
    circle.Thickness = 2
    circle.Color = fovColor
    circle.NumSides = 64
    circle.Radius = aimbotFOV
    circle.Filled = false
    circle.Visible = aimbotEnabled and showFOV
    circle.ZIndex = 999
    
    fovCircle = circle
end

local function updateFOVCircle()
    if fovCircle then
        fovCircle.Position = UserInputService:GetMouseLocation()
        fovCircle.Radius = aimbotFOV
        fovCircle.Color = fovColor
        fovCircle.Transparency = fovTransparency
        fovCircle.Visible = aimbotEnabled and showFOV
    end
end

local function isPlayerVisible(player)
    if not aimbotVisibleCheck then return true end
    
    local character = player.Character
    if not character then return false end
    
    local targetPart = character:FindFirstChild(aimbotTargetPart)
    if not targetPart then return false end
    
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin).Unit * (targetPart.Position - origin).Magnitude
    
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character, character}
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.IgnoreWater = true
    
    local result = workspace:Raycast(origin, direction, rayParams)
    
    return result == nil or result.Instance:IsDescendantOf(character)
end

local function getClosestPlayerInFOV()
    local closestPlayer = nil
    local shortestDistance = aimbotFOV
    local mousePos = UserInputService:GetMouseLocation()
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            if aimbotTeamCheck and player.Team == LocalPlayer.Team then
                continue
            end
            
            local character = player.Character
            if character then
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    local targetPart = character:FindFirstChild(aimbotTargetPart)
                    if targetPart then
                        if not aimbotIgnoreDistance then
                            local distance = (LocalPlayer.Character.HumanoidRootPart.Position - targetPart.Position).Magnitude
                            if distance > aimbotMaxDistance then
                                continue
                            end
                        end
                        
                        local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
                        if onScreen then
                            local distanceFromMouse = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                            
                            if distanceFromMouse < shortestDistance then
                                if isPlayerVisible(player) then
                                    closestPlayer = player
                                    shortestDistance = distanceFromMouse
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    return closestPlayer
end

local function smoothAim(targetPos)
    local mousePos = UserInputService:GetMouseLocation()
    local targetScreenPos = Camera:WorldToViewportPoint(targetPos)
    local targetVector = Vector2.new(targetScreenPos.X, targetScreenPos.Y)
    
    local delta = targetVector - mousePos
    local smoothDelta = delta * aimbotSmoothing * aimbotStickiness
    
    local randomOffset = Vector2.new(
        (math.random() - 0.5) * 0.5,
        (math.random() - 0.5) * 0.5
    )
    
    local finalPos = mousePos + smoothDelta + randomOffset
    
    mousemoverel((finalPos - mousePos).X, (finalPos - mousePos).Y)
end

local function aimbotLoop()
    if not aimbotEnabled then return end
    
    local mouseHeld = false
    if aimbotMouseButton == "Right" then
        mouseHeld = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
    elseif aimbotMouseButton == "Left" then
        mouseHeld = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
    end
    
    if not mouseHeld then return end
    
    local target = getClosestPlayerInFOV()
    if target then
        local character = target.Character
        if character then
            local targetPart = character:FindFirstChild(aimbotTargetPart)
            if targetPart then
                local aimPosition = targetPart.Position
                
                if aimbotPrediction and targetPart:IsA("BasePart") then
                    local velocity = targetPart.AssemblyVelocity
                    aimPosition = aimPosition + (velocity * aimbotPredictionAmount)
                end
                
                smoothAim(aimPosition)
            end
        end
    end
end

local function startAimbot()
    if aimbotConnection then
        aimbotConnection:Disconnect()
    end
    
    createFOVCircle()
    
    aimbotConnection = RunService.RenderStepped:Connect(function()
        updateFOVCircle()
        aimbotLoop()
    end)
end

local function stopAimbot()
    if aimbotConnection then
        aimbotConnection:Disconnect()
        aimbotConnection = nil
    end
    
    if fovCircle then
        fovCircle:Remove()
        fovCircle = nil
    end
end

local function applySpeedHack()
    if speedConnection then
        speedConnection:Disconnect()
    end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoidRootPart or not humanoid then return end
    
    speedConnection = RunService.Heartbeat:Connect(function(deltaTime)
        if speedHackEnabled and character.Parent and humanoidRootPart and humanoid then
            if humanoid.MoveDirection.Magnitude > 0 then
                local variance = 1 + getRandomSpeedVariance()
                local moveDirection = humanoid.MoveDirection
                
                local baseSpeed = 16
                local boostedSpeed = baseSpeed * speedMultiplier * variance
                local speedIncrease = (boostedSpeed - baseSpeed) * deltaTime * 1.5
                
                humanoidRootPart.CFrame = humanoidRootPart.CFrame + (moveDirection * speedIncrease)
            end
        end
    end)
end

local function disableSpeedHack()
    if speedConnection then
        speedConnection:Disconnect()
        speedConnection = nil
    end
end

local function onCharacterAdded(character)
    if speedConnection then
        speedConnection:Disconnect()
        speedConnection = nil
    end
    
    if speedHackEnabled then
        task.wait(0.5)
        applySpeedHack()
    end
end

LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

if LocalPlayer.Character then
    onCharacterAdded(LocalPlayer.Character)
end

local function toggleFullbright(enabled)
    if enabled then
        if not originalLighting.brightness then
            originalLighting.brightness = Lighting.Brightness
            originalLighting.ambient = Lighting.Ambient
        end
        
        Lighting.Brightness = 2
        Lighting.Ambient = Color3.fromRGB(255, 255, 255)
        Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
    else
        if originalLighting.brightness then
            Lighting.Brightness = originalLighting.brightness
            Lighting.Ambient = originalLighting.ambient
        end
    end
end

local function toggleNoFog(enabled)
    if enabled then
        if not originalLighting.fogEnd then
            originalLighting.fogEnd = Lighting.FogEnd
            originalLighting.fogStart = Lighting.FogStart
        end

        Lighting.FogEnd = 100000
        Lighting.FogStart = 0
    else
        if originalLighting.fogEnd then
            Lighting.FogEnd = originalLighting.fogEnd
            Lighting.FogStart = originalLighting.fogStart
        end
    end
end

local function changeLightColor(enabled)
    if enabled then
        if not originalLighting.lightColor then
            originalLighting.lightColor = {
                ambient = Lighting.Ambient,
                outdoorAmbient = Lighting.OutdoorAmbient,
                colorShift_Bottom = Lighting.ColorShift_Bottom,
                colorShift_Top = Lighting.ColorShift_Top
            }
        end
        
        Lighting.Ambient = lightColor
        Lighting.OutdoorAmbient = lightColor
        Lighting.ColorShift_Bottom = lightColor
        Lighting.ColorShift_Top = lightColor
    else
        if originalLighting.lightColor then
            Lighting.Ambient = originalLighting.lightColor.ambient
            Lighting.OutdoorAmbient = originalLighting.lightColor.outdoorAmbient
            Lighting.ColorShift_Bottom = originalLighting.lightColor.colorShift_Bottom
            Lighting.ColorShift_Top = originalLighting.lightColor.colorShift_Top
        end
    end
end

local function updateLightColor()
    if lightColorEnabled then
        Lighting.Ambient = lightColor
        Lighting.OutdoorAmbient = lightColor
        Lighting.ColorShift_Bottom = lightColor
        Lighting.ColorShift_Top = lightColor
    end
end

local function sendKeyPress(key)
    VirtualInputManager:SendKeyEvent(true, key, false, game)
end

local function sendKeyRelease(key)
    VirtualInputManager:SendKeyEvent(false, key, false, game)
end

local function autoCrouchLoop()
    while isAutoCrouching do
        sendKeyPress(Enum.KeyCode.C)
        task.wait(crouchTime)
        sendKeyRelease(Enum.KeyCode.C)
        task.wait(beforeRepeatDelay)
    end
end

local function startAutoCrouch()
    if not isAutoCrouching then
        isAutoCrouching = true
        task.spawn(autoCrouchLoop)
    end
end

local function stopAutoCrouch()
    if isAutoCrouching then
        isAutoCrouching = false
        sendKeyRelease(Enum.KeyCode.C)
    end
end

local function updateKeybindCache()
    local newCache = {}
    
    if keybindListAlwaysShow or isAutoCrouching then
        newCache["AutoCrouch"] = {
            name = "Auto Crouch",
            key = Options.AutoCrouchKeybind and Options.AutoCrouchKeybind.Value or "B",
            active = isAutoCrouching
        }
    end
    
    if keybindListAlwaysShow or speedHackEnabled then
        newCache["SpeedHack"] = {
            name = "Speed Hack",
            key = Options.SpeedHackKeybind and Options.SpeedHackKeybind.Value or "V",
            active = speedHackEnabled
        }
    end
    
    if keybindListAlwaysShow or aimbotEnabled then
        newCache["Aimbot"] = {
            name = "Aimbot",
            key = Options.AimbotKeybind and Options.AimbotKeybind.Value or "X",
            active = aimbotEnabled
        }
    end
    
    if keybindListAlwaysShow or espEnabled then
        newCache["ESP"] = {
            name = "ESP",
            key = Options.ESPKeybind and Options.ESPKeybind.Value or "Z",
            active = espEnabled
        }
    end
    
    local changed = false
    for k, v in pairs(newCache) do
        if not keybindCache[k] or keybindCache[k].key ~= v.key or keybindCache[k].active ~= v.active then
            changed = true
            break
        end
    end
    
    for k in pairs(keybindCache) do
        if not newCache[k] then
            changed = true
            break
        end
    end
    
    if changed then
        keybindCache = newCache
        return true
    end
    return false
end

local function createKeybindList()
    if keybindListGui then
        keybindListGui:Destroy()
        keybindListGui = nil
    end
    
    if keybindUpdateConnection then
        keybindUpdateConnection:Disconnect()
        keybindUpdateConnection = nil
    end
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "KeybindList"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    if gethui then
        screenGui.Parent = gethui()
    elseif syn and syn.protect_gui then
        syn.protect_gui(screenGui)
        screenGui.Parent = game:GetService("CoreGui")
    else
        screenGui.Parent = game:GetService("CoreGui")
    end
    
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, 200, 0, 100)
    mainFrame.Position = UDim2.new(1, -220, 0.5, -50)
    mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    mainFrame.BorderColor3 = Color3.fromRGB(60, 60, 60)
    mainFrame.BorderSizePixel = 1
    mainFrame.Parent = screenGui
    
    Library:AddToRegistry(mainFrame, {
        BackgroundColor3 = "BackgroundColor"
    })
    
    local accentLine = Instance.new("Frame")
    accentLine.Size = UDim2.new(1, 0, 0, 2)
    accentLine.Position = UDim2.new(0, 0, 0, 0)
    accentLine.BackgroundColor3 = Library.AccentColor
    accentLine.BorderSizePixel = 0
    accentLine.Parent = mainFrame
    
    Library:AddToRegistry(accentLine, {
        BackgroundColor3 = "AccentColor"
    })
    
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, 0, 0, 22)
    titleLabel.Position = UDim2.new(0, 0, 0, 2)
    titleLabel.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    titleLabel.BorderSizePixel = 0
    titleLabel.Text = "Keybinds"
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.Font = Enum.Font.Code
    titleLabel.TextSize = 14
    titleLabel.TextXAlignment = Enum.TextXAlignment.Center
    titleLabel.Parent = mainFrame
    
    Library:AddToRegistry(titleLabel, {
        BackgroundColor3 = "BackgroundColor",
        TextColor3 = "FontColor"
    })
    
    titleLabel.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            keybindDragging = true
            keybindDragStart = input.Position
            keybindStartPos = mainFrame.Position
        end
    end)
    
    titleLabel.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            keybindDragging = false
        end
    end)
    
    game:GetService("UserInputService").InputChanged:Connect(function(input)
        if keybindDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - keybindDragStart
            mainFrame.Position = UDim2.new(
                keybindStartPos.X.Scale,
                keybindStartPos.X.Offset + delta.X,
                keybindStartPos.Y.Scale,
                keybindStartPos.Y.Offset + delta.Y
            )
        end
    end)
    
    local container = Instance.new("Frame")
    container.Name = "Container"
    container.Size = UDim2.new(1, -16, 1, -32)
    container.Position = UDim2.new(0, 8, 0, 28)
    container.BackgroundTransparency = 1
    container.Parent = mainFrame
    
    local listLayout = Instance.new("UIListLayout")
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    listLayout.Padding = UDim.new(0, 6)
    listLayout.Parent = container
    
    keybindListGui = screenGui
    
    local function updateKeybindList()
        if not keybindListEnabled then
            screenGui.Enabled = false
            return
        end
        
        if not updateKeybindCache() then
            return
        end
        
        for _, child in pairs(container:GetChildren()) do
            if child:IsA("Frame") then
                child:Destroy()
            end
        end
        
        for _, keybind in pairs(keybindCache) do
            local keybindFrame = Instance.new("Frame")
            keybindFrame.Size = UDim2.new(1, 0, 0, 18)
            keybindFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
            keybindFrame.BorderSizePixel = 0
            keybindFrame.Parent = container
            
            Library:AddToRegistry(keybindFrame, {
                BackgroundColor3 = "BackgroundColor"
            })
            
            if keybind.active then
                local activeAccent = Instance.new("Frame")
                activeAccent.Size = UDim2.new(0, 2, 1, 0)
                activeAccent.Position = UDim2.new(0, 0, 0, 0)
                activeAccent.BackgroundColor3 = Library.AccentColor
                activeAccent.BorderSizePixel = 0
                activeAccent.Parent = keybindFrame
                
                Library:AddToRegistry(activeAccent, {
                    BackgroundColor3 = "AccentColor"
                })
            end
            
            local nameLabel = Instance.new("TextLabel")
            nameLabel.Size = UDim2.new(0.55, 0, 1, 0)
            nameLabel.Position = UDim2.new(0, 6, 0, 0)
            nameLabel.BackgroundTransparency = 1
            nameLabel.Text = keybind.name
            nameLabel.TextColor3 = keybind.active and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(180, 180, 180)
            nameLabel.Font = Enum.Font.Code
            nameLabel.TextSize = 13
            nameLabel.TextXAlignment = Enum.TextXAlignment.Left
            nameLabel.Parent = keybindFrame
            
            Library:AddToRegistry(nameLabel, {
                TextColor3 = "FontColor"
            })
            
            local keyLabel = Instance.new("TextLabel")
            keyLabel.Size = UDim2.new(0.4, 0, 1, 0)
            keyLabel.Position = UDim2.new(0.55, 0, 0, 0)
            keyLabel.BackgroundTransparency = 1
            keyLabel.Text = "[" .. keybind.key .. "]"
            keyLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
            keyLabel.Font = Enum.Font.Code
            keyLabel.TextSize = 13
            keyLabel.TextXAlignment = Enum.TextXAlignment.Right
            keyLabel.Parent = keybindFrame
            
            Library:AddToRegistry(keyLabel, {
                TextColor3 = "FontColor"
            })
            
            local padding = Instance.new("UIPadding")
            padding.PaddingRight = UDim.new(0, 6)
            padding.Parent = keyLabel
        end
        
        local count = 0
        for _ in pairs(keybindCache) do count = count + 1 end
        local contentHeight = 30 + (count * 24)
        mainFrame.Size = UDim2.new(0, 200, 0, math.max(contentHeight, 50))
        
        screenGui.Enabled = true
    end
    
    keybindUpdateConnection = RunService.RenderStepped:Connect(function()
        if keybindListEnabled then
            updateKeybindList()
        end
    end)
    
    updateKeybindList()
end

local function createCrosshair()
    if crosshairGui then
        crosshairGui:Destroy()
        crosshairGui = nil
    end
    
    if spinConnection then
        spinConnection:Disconnect()
        spinConnection = nil
    end
    
    if rainbowConnection then
        rainbowConnection:Disconnect()
        rainbowConnection = nil
    end
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "CrosshairGui"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    if gethui then
        screenGui.Parent = gethui()
    elseif syn and syn.protect_gui then
        syn.protect_gui(screenGui)
        screenGui.Parent = game:GetService("CoreGui")
    else
        screenGui.Parent = game:GetService("CoreGui")
    end
    
    local crosshairFrame = Instance.new("Frame")
    crosshairFrame.Name = "CrosshairFrame"
    crosshairFrame.Size = UDim2.new(0, 100, 0, 100)
    crosshairFrame.Position = UDim2.new(0.5, crosshairOffsetX, 0.5, crosshairOffsetY)
    crosshairFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    crosshairFrame.BackgroundTransparency = 1
    crosshairFrame.Parent = screenGui
    
    local function createLineWithOutline(size, position, isVertical)
        local container = Instance.new("Frame")
        container.Size = size
        container.Position = position
        container.BackgroundTransparency = 1
        container.Parent = crosshairFrame

        local outline = Instance.new("Frame")
        local outlineOffset = outlineThickness
        if isVertical then
            outline.Size = UDim2.new(1, outlineOffset * 2, 1, outlineOffset * 2)
            outline.Position = UDim2.new(0, -outlineOffset, 0, -outlineOffset)
        else
            outline.Size = UDim2.new(1, outlineOffset * 2, 1, outlineOffset * 2)
            outline.Position = UDim2.new(0, -outlineOffset, 0, -outlineOffset)
        end
        outline.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        outline.BorderSizePixel = 0
        outline.ZIndex = 1
        outline.Name = "Outline"
        outline.Parent = container
        
        local line = Instance.new("Frame")
        line.Size = UDim2.new(1, 0, 1, 0)
        line.Position = UDim2.new(0, 0, 0, 0)
        line.BackgroundColor3 = crosshairColor
        line.BorderSizePixel = 0
        line.ZIndex = 2
        line.Name = "MainLine"
        line.Parent = container
        
        return container
    end

    local halfSize = crosshairSize / 2
    local halfThickness = crosshairThickness / 2
    local halfGap = crosshairGap / 2
    
    createLineWithOutline(
        UDim2.new(0, halfSize - halfGap, 0, crosshairThickness),
        UDim2.new(0.5, -halfSize, 0.5, -halfThickness),
        false
    )
    
    createLineWithOutline(
        UDim2.new(0, halfSize - halfGap, 0, crosshairThickness),
        UDim2.new(0.5, halfGap, 0.5, -halfThickness),
        false
    )
    
    createLineWithOutline(
        UDim2.new(0, crosshairThickness, 0, halfSize - halfGap),
        UDim2.new(0.5, -halfThickness, 0.5, -halfSize),
        true
    )
    
    createLineWithOutline(
        UDim2.new(0, crosshairThickness, 0, halfSize - halfGap),
        UDim2.new(0.5, -halfThickness, 0.5, halfGap),
        true
    )
    
    if centerDotEnabled then
        local dotSize = 4
        local dotContainer = Instance.new("Frame")
        dotContainer.Size = UDim2.new(0, dotSize + (outlineThickness * 2), 0, dotSize + (outlineThickness * 2))
        dotContainer.Position = UDim2.new(0.5, -(dotSize + (outlineThickness * 2))/2, 0.5, -(dotSize + (outlineThickness * 2))/2)
        dotContainer.BackgroundTransparency = 1
        dotContainer.Parent = crosshairFrame
        
        local dotOutline = Instance.new("Frame")
        dotOutline.Size = UDim2.new(0, dotSize + (outlineThickness * 2), 0, dotSize + (outlineThickness * 2))
        dotOutline.Position = UDim2.new(0, 0, 0, 0)
        dotOutline.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        dotOutline.BorderSizePixel = 0
        dotOutline.ZIndex = 1
        dotOutline.Name = "DotOutline"
        dotOutline.Parent = dotContainer
        
        local outlineCorner = Instance.new("UICorner")
        outlineCorner.CornerRadius = UDim.new(1, 0)
        outlineCorner.Parent = dotOutline
        
        local centerDot = Instance.new("Frame")
        centerDot.Size = UDim2.new(0, dotSize, 0, dotSize)
        centerDot.Position = UDim2.new(0, outlineThickness, 0, outlineThickness)
        centerDot.BackgroundColor3 = crosshairColor
        centerDot.BorderSizePixel = 0
        centerDot.ZIndex = 2
        centerDot.Name = "CenterDot"
        centerDot.Parent = dotContainer
        
        local centerCorner = Instance.new("UICorner")
        centerCorner.CornerRadius = UDim.new(1, 0)
        centerCorner.Parent = centerDot
    end
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(0, 200, 0, 20)
    textLabel.Position = UDim2.new(0.5, 0, 0.5, textOffsetY)
    textLabel.AnchorPoint = Vector2.new(0.5, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = crosshairText
    textLabel.TextColor3 = crosshairColor
    textLabel.TextStrokeTransparency = 0
    textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    textLabel.Font = Enum.Font.Code
    textLabel.TextSize = 14
    textLabel.Name = "CrosshairTextLabel"
    textLabel.Parent = screenGui
    
    crosshairGui = screenGui
    
    local rotation = 0
    spinConnection = RunService.RenderStepped:Connect(function(dt)
        if crosshairEnabled then
            rotation = rotation + (crosshairSpinSpeed * dt * 60)
            crosshairFrame.Rotation = rotation
        end
    end)
    
    if rainbowMode then
        rainbowConnection = RunService.RenderStepped:Connect(function()
            if crosshairEnabled and rainbowMode then
                local rainbowColor = getRainbowColor()
                
                local frame = crosshairGui:FindFirstChild("CrosshairFrame")
                if frame then
                    for _, child in pairs(frame:GetDescendants()) do
                        if child.Name == "MainLine" or child.Name == "CenterDot" then
                            child.BackgroundColor3 = rainbowColor
                        end
                    end
                end
                
                local textLabel = crosshairGui:FindFirstChild("CrosshairTextLabel")
                if textLabel then
                    textLabel.TextColor3 = rainbowColor
                end
            end
        end)
    end
end

local function updateCrosshairColor()
    if crosshairGui and not rainbowMode then
        local frame = crosshairGui:FindFirstChild("CrosshairFrame")
        if frame then
            for _, child in pairs(frame:GetDescendants()) do
                if child.Name == "MainLine" or child.Name == "CenterDot" then
                    child.BackgroundColor3 = crosshairColor
                end
            end
        end
        
        local textLabel = crosshairGui:FindFirstChild("CrosshairTextLabel")
        if textLabel then
            textLabel.TextColor3 = crosshairColor
        end
    end
end

local function updateTextOffset()
    if crosshairGui then
        local textLabel = crosshairGui:FindFirstChild("CrosshairTextLabel")
        if textLabel then
            textLabel.Position = UDim2.new(0.5, 0, 0.5, textOffsetY)
        end
    end
end

local function updateCrosshairPosition()
    if crosshairGui then
        local frame = crosshairGui:FindFirstChild("CrosshairFrame")
        if frame then
            frame.Position = UDim2.new(0.5, crosshairOffsetX, 0.5, crosshairOffsetY)
        end
    end
end

local ESPGroup = Tabs.Visuals:AddLeftGroupbox('Player ESP')

ESPGroup:AddLabel('üëÅÔ∏è See Players Through Walls')
ESPGroup:AddLabel('Press keybind to toggle ESP')

ESPGroup:AddLabel('Keybind'):AddKeyPicker('ESPKeybind', {
    Default = 'Z',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'ESP Toggle',
    Callback = function(Value)
        espEnabled = Value
        if Value then
            startESP()
        else
            stopESP()
        end
    end
})

ESPGroup:AddDivider()
ESPGroup:AddLabel('ESP Components')

ESPGroup:AddToggle('ESPBox', {
    Text = 'Show Box',
    Default = true,
    Tooltip = 'Display bounding box around players',
    Callback = function(Value)
        espBoxEnabled = Value
    end
})

ESPGroup:AddToggle('ESPName', {
    Text = 'Show Name',
    Default = true,
    Tooltip = 'Display player names',
    Callback = function(Value)
        espNameEnabled = Value
    end
})

ESPGroup:AddToggle('ESPHealth', {
    Text = 'Show Health',
    Default = true,
    Tooltip = 'Display health bar and HP text',
    Callback = function(Value)
        espHealthEnabled = Value
    end
})

ESPGroup:AddToggle('ESPDistance', {
    Text = 'Show Distance',
    Default = true,
    Tooltip = 'Display distance to player',
    Callback = function(Value)
        espDistanceEnabled = Value
    end
})

ESPGroup:AddDivider()
ESPGroup:AddLabel('Box Settings')

ESPGroup:AddToggle('ESPFillBox', {
    Text = 'Fill Box',
    Default = false,
    Tooltip = 'Fill the box with semi-transparent color',
    Callback = function(Value)
        espFillBox = Value
    end
})

ESPGroup:AddSlider('ESPFillTransparency', {
    Text = 'Fill Transparency',
    Default = 0.1,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(Value)
        espFillTransparency = Value
    end
})

ESPGroup:AddSlider('ESPBoxThickness', {
    Text = 'Box Thickness',
    Default = 1,
    Min = 1,
    Max = 5,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        espBoxThickness = Value
    end
})

ESPGroup:AddDivider()
ESPGroup:AddLabel('Color Settings')

ESPGroup:AddToggle('ESPRainbow', {
    Text = 'Rainbow ESP',
    Default = false,
    Tooltip = 'Cycle through rainbow colors',
    Callback = function(Value)
        espRainbow = Value
    end
})

ESPGroup:AddToggle('ESPTeamColor', {
    Text = 'Team Color',
    Default = true,
    Tooltip = 'Color ESP based on team',
    Callback = function(Value)
        espTeamColor = Value
    end
})

ESPGroup:AddLabel('Box Color'):AddColorPicker('ESPBoxColor', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Box Color',
    Transparency = 0,
    Callback = function(Value)
        espBoxColor = Value
    end
})

ESPGroup:AddLabel('Name Color'):AddColorPicker('ESPNameColor', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Name Color',
    Transparency = 0,
    Callback = function(Value)
        espNameColor = Value
    end
})

ESPGroup:AddDivider()
ESPGroup:AddLabel('Other Settings')

ESPGroup:AddSlider('ESPTextSize', {
    Text = 'Text Size',
    Default = 13,
    Min = 10,
    Max = 20,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        espTextSize = Value
    end
})

ESPGroup:AddToggle('ESPTeamCheck', {
    Text = 'Team Check',
    Default = true,
    Tooltip = "Don't show teammates",
    Callback = function(Value)
        espTeamCheck = Value
    end
})

ESPGroup:AddSlider('ESPMaxDistance', {
    Text = 'Max Distance',
    Default = 1000,
    Min = 100,
    Max = 5000,
    Rounding = 0,
    Compact = false,
    Suffix = ' studs',
    Callback = function(Value)
        espMaxDistance = Value
    end
})

ESPGroup:AddSlider('ESPUpdateRate', {
    Text = 'Update Rate',
    Default = 0.001,
    Min = 0.001,
    Max = 0.1,
    Rounding = 3,
    Compact = false,
    Suffix = 's',
    Tooltip = 'Lower = smoother (uses more CPU)',
    Callback = function(Value)
        espUpdateRate = Value
    end
})

ESPGroup:AddDivider()
ESPGroup:AddLabel('‚ö†Ô∏è Anti-Detection Tips:')
ESPGroup:AddLabel('‚Ä¢ Uses Drawing API (client-side)')
ESPGroup:AddLabel('‚Ä¢ Throttled updates for performance')
ESPGroup:AddLabel('‚Ä¢ Team check recommended')
ESPGroup:AddLabel('‚Ä¢ Keep max distance reasonable')

local AimbotGroup = Tabs.Combat:AddLeftGroupbox('Aimbot')

AimbotGroup:AddLabel('üéØ Silent Aimbot')
AimbotGroup:AddLabel('Press keybind to toggle')

AimbotGroup:AddLabel('Keybind'):AddKeyPicker('AimbotKeybind', {
    Default = 'X',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Aimbot',
    Callback = function(Value)
        aimbotEnabled = Value
        if Value then
            startAimbot()
        else
            stopAimbot()
        end
    end
})

AimbotGroup:AddDivider()
AimbotGroup:AddLabel('Targeting Settings')

AimbotGroup:AddDropdown('AimbotMouseButton', {
    Values = {'Right', 'Left'},
    Default = 1,
    Multi = false,
    Text = 'Activation Button',
    Tooltip = 'Which mouse button activates aimbot',
    Callback = function(Value)
        aimbotMouseButton = Value
    end
})

AimbotGroup:AddDropdown('TargetPart', {
    Values = {'Head', 'Torso', 'HumanoidRootPart'},
    Default = 1,
    Multi = false,
    Text = 'Target Part',
    Tooltip = 'Body part to aim at',
    Callback = function(Value)
        aimbotTargetPart = Value
    end
})

AimbotGroup:AddSlider('AimbotFOV', {
    Text = 'FOV Size',
    Default = 150,
    Min = 50,
    Max = 500,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        aimbotFOV = Value
        if fovCircle then
            fovCircle.Radius = Value
        end
    end
})

AimbotGroup:AddSlider('AimbotSmoothing', {
    Text = 'Smoothing',
    Default = 0.15,
    Min = 0.05,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(Value)
        aimbotSmoothing = Value
    end
})

AimbotGroup:AddSlider('AimbotStickiness', {
    Text = 'Stickiness',
    Default = 0.8,
    Min = 0.1,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Tooltip = 'How strongly aimbot follows target',
    Callback = function(Value)
        aimbotStickiness = Value
    end
})

AimbotGroup:AddDivider()
AimbotGroup:AddLabel('Safety & Checks')

AimbotGroup:AddToggle('VisibleCheck', {
    Text = 'Visible Check',
    Default = true,
    Tooltip = 'Only aim at visible players',
    Callback = function(Value)
        aimbotVisibleCheck = Value
    end
})

AimbotGroup:AddToggle('TeamCheck', {
    Text = 'Team Check',
    Default = true,
    Tooltip = "Don't aim at teammates",
    Callback = function(Value)
        aimbotTeamCheck = Value
    end
})

AimbotGroup:AddToggle('IgnoreDistance', {
    Text = 'Ignore Distance',
    Default = false,
    Tooltip = 'Aim at targets regardless of distance',
    Callback = function(Value)
        aimbotIgnoreDistance = Value
    end
})

AimbotGroup:AddSlider('MaxDistance', {
    Text = 'Max Distance',
    Default = 500,
    Min = 100,
    Max = 2000,
    Rounding = 0,
    Compact = false,
    Suffix = ' studs',
    Callback = function(Value)
        aimbotMaxDistance = Value
    end
})

AimbotGroup:AddDivider()
AimbotGroup:AddLabel('Prediction')

AimbotGroup:AddToggle('Prediction', {
    Text = 'Enable Prediction',
    Default = false,
    Tooltip = 'Predict target movement',
    Callback = function(Value)
        aimbotPrediction = Value
    end
})

AimbotGroup:AddSlider('PredictionAmount', {
    Text = 'Prediction Amount',
    Default = 0.13,
    Min = 0.05,
    Max = 0.3,
    Rounding = 2,
    Compact = false,
    Callback = function(Value)
        aimbotPredictionAmount = Value
    end
})

AimbotGroup:AddDivider()
AimbotGroup:AddLabel('FOV Circle')

AimbotGroup:AddToggle('ShowFOV', {
    Text = 'Show FOV Circle',
    Default = true,
    Tooltip = 'Display FOV indicator',
    Callback = function(Value)
        showFOV = Value
        if aimbotEnabled then
            if Value then
                createFOVCircle()
            elseif fovCircle then
                fovCircle:Remove()
                fovCircle = nil
            end
        end
    end
})

AimbotGroup:AddLabel('FOV Color'):AddColorPicker('FOVColor', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'FOV Circle Color',
    Transparency = 0.5,
    Callback = function(Value)
        fovColor = Value
        if fovCircle then
            fovCircle.Color = Value
        end
    end
})

AimbotGroup:AddSlider('FOVTransparency', {
    Text = 'FOV Transparency',
    Default = 0.5,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(Value)
        fovTransparency = Value
        if fovCircle then
            fovCircle.Transparency = Value
        end
    end
})

AimbotGroup:AddDivider()
AimbotGroup:AddLabel('‚ö†Ô∏è Anti-Cheat Info:')
AimbotGroup:AddLabel('‚Ä¢ Uses mousemoverel (safer)')
AimbotGroup:AddLabel('‚Ä¢ Smooth aim with randomization')
AimbotGroup:AddLabel('‚Ä¢ Lower smoothing = more legit')
AimbotGroup:AddLabel('‚Ä¢ Keep FOV reasonable (<200)')

VisualsGroup:AddToggle('CrosshairToggle', {
    Text = 'Enable Crosshair',
    Default = false,
    Tooltip = 'Shows a spinning crosshair',
    Callback = function(Value)
        crosshairEnabled = Value
        
        if Value then
            createCrosshair()
        else
            if crosshairGui then
                crosshairGui:Destroy()
                crosshairGui = nil
            end
            if spinConnection then
                spinConnection:Disconnect()
                spinConnection = nil
            end
            if rainbowConnection then
                rainbowConnection:Disconnect()
                rainbowConnection = nil
            end
        end
    end
})

VisualsGroup:AddDivider()
VisualsGroup:AddLabel('Color & Style')

VisualsGroup:AddToggle('RainbowMode', {
    Text = 'Rainbow Mode',
    Default = false,
    Tooltip = 'Cycle through rainbow colors',
    Callback = function(Value)
        rainbowMode = Value
        
        if Value then
            if crosshairEnabled then
                createCrosshair()
            end
        else
            if rainbowConnection then
                rainbowConnection:Disconnect()
                rainbowConnection = nil
            end
            updateCrosshairColor()
        end
    end
})

VisualsGroup:AddSlider('RainbowSpeed', {
    Text = 'Rainbow Speed',
    Default = 2.2,
    Min = 0.1,
    Max = 5,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        rainbowSpeed = Value
    end
})

VisualsGroup:AddLabel('Crosshair Color'):AddColorPicker('CrosshairColor', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Crosshair Color',
    Transparency = 0,
    Callback = function(Value)
        crosshairColor = Value
        if not rainbowMode then
            updateCrosshairColor()
        end
    end
})

VisualsGroup:AddSlider('CrosshairSpeed', {
    Text = 'Spin Speed',
    Default = 3.5,
    Min = 0,
    Max = 20,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        crosshairSpinSpeed = Value
    end
})

VisualsGroup:AddDivider()
VisualsGroup:AddLabel('Size & Spacing')

VisualsGroup:AddSlider('CrosshairSize', {
    Text = 'Crosshair Size',
    Default = 27.8,
    Min = 10,
    Max = 100,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        crosshairSize = Value
        if crosshairEnabled then
            createCrosshair()
        end
    end
})

VisualsGroup:AddSlider('CrosshairThickness', {
    Text = 'Line Thickness',
    Default = 2.3,
    Min = 1,
    Max = 10,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        crosshairThickness = Value
        if crosshairEnabled then
            createCrosshair()
        end
    end
})

VisualsGroup:AddSlider('OutlineThickness', {
    Text = 'Outline Thickness',
    Default = 2,
    Min = 1,
    Max = 6,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        outlineThickness = Value
        if crosshairEnabled then
            createCrosshair()
        end
    end
})

VisualsGroup:AddSlider('CrosshairGap', {
    Text = 'Bar Spacing (Gap)',
    Default = 8.9,
    Min = 0,
    Max = 30,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        crosshairGap = Value
        if crosshairEnabled then
            createCrosshair()
        end
    end
})

VisualsGroup:AddToggle('CenterDotToggle', {
    Text = 'Show Center Dot',
    Default = true,
    Tooltip = 'Toggle center dot visibility',
    Callback = function(Value)
        centerDotEnabled = Value
        if crosshairEnabled then
            createCrosshair()
        end
    end
})

VisualsGroup:AddDivider()
VisualsGroup:AddLabel('Text Settings')

VisualsGroup:AddInput('CrosshairText', {
    Default = 'Reden.Hook',
    Numeric = false,
    Finished = false,
    Text = 'Crosshair Text',
    Tooltip = 'Text displayed under crosshair',
    Placeholder = 'Enter text...',
    Callback = function(Value)
        crosshairText = Value
        
        if crosshairGui then
            local textLabel = crosshairGui:FindFirstChild("CrosshairTextLabel")
            if textLabel then
                textLabel.Text = Value
            end
        end
    end
})

VisualsGroup:AddSlider('TextOffset', {
    Text = 'Name Offset (Y)',
    Default = 20,
    Min = 5,
    Max = 200,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        textOffsetY = Value
        updateTextOffset()
    end
})

VisualsGroup:AddDivider()
VisualsGroup:AddLabel('Position Adjustment')

VisualsGroup:AddSlider('CrosshairOffsetX', {
    Text = 'Crosshair X Position',
    Default = 0,
    Min = -100,
    Max = 100,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        crosshairOffsetX = Value
        updateCrosshairPosition()
    end
})

VisualsGroup:AddSlider('CrosshairOffsetY', {
    Text = 'Crosshair Y Position',
    Default = -29.3,
    Min = -100,
    Max = 100,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        crosshairOffsetY = Value
        updateCrosshairPosition()
    end
})

local EnhancementsGroup = Tabs.Visuals:AddRightGroupbox('Visual Enhancements')

EnhancementsGroup:AddLabel('üí° Make the game brighter')

EnhancementsGroup:AddToggle('FullbrightToggle', {
    Text = 'Fullbright',
    Default = false,
    Tooltip = 'Removes shadows and makes everything bright',
    Callback = function(Value)
        fullbrightEnabled = Value
        toggleFullbright(Value)
    end
})

EnhancementsGroup:AddToggle('NoFogToggle', {
    Text = 'No Fog',
    Default = false,
    Tooltip = 'Removes fog for better visibility',
    Callback = function(Value)
        toggleNoFog(Value)
    end
})

EnhancementsGroup:AddDivider()
EnhancementsGroup:AddLabel('üé® Light Customization')

EnhancementsGroup:AddToggle('LightColorToggle', {
    Text = 'Custom Light Color',
    Default = false,
    Tooltip = 'Change the lighting and ambient color',
    Callback = function(Value)
        lightColorEnabled = Value
        changeLightColor(Value)
    end
})

EnhancementsGroup:AddLabel('Light Color'):AddColorPicker('LightColorPicker', {
    Default = Color3.fromRGB(0, 0, 0),
    Title = 'Light Color',
    Transparency = 0,
    Callback = function(Value)
        lightColor = Value
        updateLightColor()
    end
})

local KeybindListGroup = Tabs.Visuals:AddRightGroupbox('Keybind List')

KeybindListGroup:AddToggle('KeybindListToggle', {
    Text = 'Show Keybind List',
    Default = false,
    Tooltip = 'Display active keybinds on screen',
    Callback = function(Value)
        keybindListEnabled = Value
        if Value then
            createKeybindList()
        elseif keybindListGui then
            keybindListGui.Enabled = false
        end
    end
})

KeybindListGroup:AddToggle('KeybindListAlwaysShow', {
    Text = 'Always Show',
    Default = true,
    Tooltip = 'Show all keybinds or only active ones',
    Callback = function(Value)
        keybindListAlwaysShow = Value
    end
})

local SpeedGroup = Tabs.Combat:AddRightGroupbox('Speed Hack')

SpeedGroup:AddLabel('‚ö° CFrame Speed Modification')
SpeedGroup:AddLabel('Press keybind to toggle on/off')

SpeedGroup:AddLabel('Keybind'):AddKeyPicker('SpeedHackKeybind', {
    Default = 'V',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Speed Hack',
    Callback = function(Value)
        speedHackEnabled = Value
        if Value then
            applySpeedHack()
        else
            disableSpeedHack()
        end
    end
})

SpeedGroup:AddDivider()
SpeedGroup:AddLabel('Speed Settings')

SpeedGroup:AddSlider('SpeedMultiplier', {
    Text = 'Speed Multiplier',
    Default = 2.5,
    Min = 1,
    Max = 5,
    Rounding = 2,
    Compact = false,
    Suffix = 'x',
    Callback = function(Value)
        speedMultiplier = Value
    end
})

SpeedGroup:AddToggle('SpeedRandomization', {
    Text = 'Speed Randomization',
    Default = true,
    Tooltip = 'Adds random variance to avoid detection',
    Callback = function(Value)
        speedRandomization = Value
    end
})

SpeedGroup:AddSlider('SpeedVariance', {
    Text = 'Variance Amount',
    Default = 0.1,
    Min = 0,
    Max = 0.3,
    Rounding = 2,
    Compact = false,
    Suffix = '%',
    Callback = function(Value)
        speedVariance = Value
    end
})

SpeedGroup:AddDivider()
SpeedGroup:AddLabel('‚ö†Ô∏è CFrame Method Info:')
SpeedGroup:AddLabel('‚Ä¢ Direct position manipulation')
SpeedGroup:AddLabel('‚Ä¢ Enhanced speed boost (1.5x)')
SpeedGroup:AddLabel('‚Ä¢ Random variance applied')
SpeedGroup:AddLabel('‚Ä¢ Higher speeds = more detection risk')

local CombatGroup = Tabs.Combat:AddRightGroupbox('Auto Crouch')

CombatGroup:AddLabel('Press keybind to toggle on/off')

CombatGroup:AddLabel('Keybind'):AddKeyPicker('AutoCrouchKeybind', {
    Default = 'B',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Auto Crouch',
    Callback = function(Value)
        if Value then
            startAutoCrouch()
        else
            stopAutoCrouch()
        end
    end
})

CombatGroup:AddDivider()
CombatGroup:AddLabel('Timing Settings')

CombatGroup:AddSlider('CrouchTime', {
    Text = 'Crouch Time',
    Default = 1,
    Min = 0.1,
    Max = 5,
    Rounding = 1,
    Compact = false,
    Suffix = 's',
    Callback = function(Value)
        crouchTime = Value
    end
})

CombatGroup:AddSlider('BeforeRepeatDelay', {
    Text = 'Before Repeat',
    Default = 0.5,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Suffix = 's',
    Callback = function(Value)
        beforeRepeatDelay = Value
    end
})

CombatGroup:AddDivider()

local StreamGroup = Tabs.StreamProtection:AddLeftGroupbox('Username Spoof')

local spoofedUsername = ""
local usernameEnabled = false

StreamGroup:AddInput('SpoofUsername', {
    Default = '',
    Numeric = false,
    Finished = false,
    Text = 'Spoofed Username',
    Tooltip = 'Enter the fake username to display',
    Placeholder = 'Enter username...',
    Callback = function(Value)
        spoofedUsername = Value
    end
})

StreamGroup:AddToggle('EnableUsernameSpoof', {
    Text = 'Enable Username Spoof',
    Default = false,
    Tooltip = 'Hides your real username',
    Callback = function(Value)
        usernameEnabled = Value
        
        if Value and spoofedUsername ~= "" then
            xpcall(function()
                local G,P,LP=game,game:GetService("Players"),game:GetService("Players").LocalPlayer
                local fake=spoofedUsername
                local vid=LP.UserId
                local vn=LP.Name
                local dn=LP.DisplayName
                local function updateUI(obj)
                    if obj:IsA("TextLabel")or obj:IsA("TextButton")or obj:IsA("TextBox")then
                        if obj.Text:find(vn)or obj.Text:find(dn)then
                            obj.Text=obj.Text:gsub(vn,fake):gsub(dn,fake)
                        end
                        obj:GetPropertyChangedSignal("Text"):Connect(function()
                            obj.Text=obj.Text:gsub(vn,fake):gsub(dn,fake)
                        end)
                    end
                end
                for _,v in G:GetDescendants()do updateUI(v)end
                G.DescendantAdded:Connect(updateUI)
            end,function()end)
        elseif Value and spoofedUsername == "" then
            Options.EnableUsernameSpoof:SetValue(false)
        end
    end
})

Library:SetWatermarkVisibility(false)

local MenuGroup = Tabs.Settings:AddLeftGroupbox('Menu Controls')

MenuGroup:AddLabel('Toggle Menu Key'):AddKeyPicker('MenuKeybind', {
    Default = 'RightShift',
    NoUI = true,
    Text = 'Menu keybind'
})

MenuGroup:AddButton({
    Text = 'Close Menu',
    Func = function()
        if spinConnection then
            spinConnection:Disconnect()
            spinConnection = nil
        end
        if rainbowConnection then
            rainbowConnection:Disconnect()
            rainbowConnection = nil
        end
        if keybindUpdateConnection then
            keybindUpdateConnection:Disconnect()
            keybindUpdateConnection = nil
        end
        if speedConnection then
            speedConnection:Disconnect()
            speedConnection = nil
        end
        if espConnection then
            espConnection:Disconnect()
            espConnection = nil
        end
        stopAutoCrouch()
        disableSpeedHack()
        stopAimbot()
        stopESP()
        Library:Unload()
    end,
    Tooltip = 'Destroy the menu completely'
})

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

ThemeManager:SetFolder('Reden.Hook')
SaveManager:SetFolder('Reden.Hook/configs')

SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:ApplyToTab(Tabs.Settings)

print("===========================================================")
print("[Reden.Hook] Loaded Successfully")
print("[Reden.Hook] Press RightShift to toggle menu")
print("[Reden.Hook] New Features!!!: Aimbot + Speedhack + ESP")
print("===========================================================")
