local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Window = Library:CreateWindow({
    Title = 'Reden.Hook',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Combat = Window:AddTab('Combat'),
    Visuals = Window:AddTab('Visuals'),
    StreamProtection = Window:AddTab('Stream Protection'),
    Settings = Window:AddTab('Settings'),
}

local VisualsGroup = Tabs.Visuals:AddRightGroupbox('Visuals')

local crosshairEnabled = false
local crosshairSpinSpeed = 3.5
local crosshairText = "Reden.Hook"
local crosshairColor = Color3.fromRGB(255, 255, 255)
local crosshairSize = 27.8
local crosshairThickness = 2.3
local crosshairGap = 8.9
local outlineThickness = 2
local centerDotEnabled = true
local textOffsetY = 20
local crosshairOffsetX = 0
local crosshairOffsetY = -29.3
local rainbowMode = false
local rainbowSpeed = 2.2
local crosshairGui = nil
local spinConnection = nil
local rainbowConnection = nil

local fullbrightEnabled = false
local lightColorEnabled = false
local lightColor = Color3.fromRGB(135, 206, 235)
local originalLighting = {}

local autoCrouchEnabled = false
local crouchTime = 1 
local beforeRepeatDelay = 0.5 
local isAutoCrouching = false

local keybindListEnabled = false
local keybindListAlwaysShow = true
local keybindListGui = nil
local keybindUpdateConnection = nil
local keybindCache = {}
local keybindDragging = false
local keybindDragStart = nil
local keybindStartPos = nil

local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local VirtualInputManager = game:GetService("VirtualInputManager")

local function getRainbowColor(offset)
    local hue = (tick() * rainbowSpeed * 0.5 + (offset or 0)) % 1
    return Color3.fromHSV(hue, 1, 1)
end

local function toggleFullbright(enabled)
    if enabled then
        if not originalLighting.brightness then
            originalLighting.brightness = Lighting.Brightness
            originalLighting.ambient = Lighting.Ambient
        end
        
        Lighting.Brightness = 2
        Lighting.Ambient = Color3.fromRGB(255, 255, 255)
        Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
    else
        if originalLighting.brightness then
            Lighting.Brightness = originalLighting.brightness
            Lighting.Ambient = originalLighting.ambient
        end
    end
end

local function toggleNoFog(enabled)
    if enabled then
        if not originalLighting.fogEnd then
            originalLighting.fogEnd = Lighting.FogEnd
            originalLighting.fogStart = Lighting.FogStart
        end

        Lighting.FogEnd = 100000
        Lighting.FogStart = 0
    else
        if originalLighting.fogEnd then
            Lighting.FogEnd = originalLighting.fogEnd
            Lighting.FogStart = originalLighting.fogStart
        end
    end
end

local function changeLightColor(enabled)
    if enabled then
        if not originalLighting.lightColor then
            originalLighting.lightColor = {
                ambient = Lighting.Ambient,
                outdoorAmbient = Lighting.OutdoorAmbient,
                colorShift_Bottom = Lighting.ColorShift_Bottom,
                colorShift_Top = Lighting.ColorShift_Top
            }
        end
        
        Lighting.Ambient = lightColor
        Lighting.OutdoorAmbient = lightColor
        Lighting.ColorShift_Bottom = lightColor
        Lighting.ColorShift_Top = lightColor
    else
        if originalLighting.lightColor then
            Lighting.Ambient = originalLighting.lightColor.ambient
            Lighting.OutdoorAmbient = originalLighting.lightColor.outdoorAmbient
            Lighting.ColorShift_Bottom = originalLighting.lightColor.colorShift_Bottom
            Lighting.ColorShift_Top = originalLighting.lightColor.colorShift_Top
        end
    end
end

local function updateLightColor()
    if lightColorEnabled then
        Lighting.Ambient = lightColor
        Lighting.OutdoorAmbient = lightColor
        Lighting.ColorShift_Bottom = lightColor
        Lighting.ColorShift_Top = lightColor
    end
end

local function sendKeyPress(key)
    VirtualInputManager:SendKeyEvent(true, key, false, game)
end

local function sendKeyRelease(key)
    VirtualInputManager:SendKeyEvent(false, key, false, game)
end

local function autoCrouchLoop()
    while isAutoCrouching do
        sendKeyPress(Enum.KeyCode.C)
        task.wait(crouchTime)
        sendKeyRelease(Enum.KeyCode.C)
        task.wait(beforeRepeatDelay)
    end
end

local function startAutoCrouch()
    if not isAutoCrouching then
        isAutoCrouching = true
        task.spawn(autoCrouchLoop)
    end
end

local function stopAutoCrouch()
    if isAutoCrouching then
        isAutoCrouching = false
        sendKeyRelease(Enum.KeyCode.C)
    end
end

local function updateKeybindCache()
    local newCache = {}
    
    if keybindListAlwaysShow or isAutoCrouching then
        newCache["AutoCrouch"] = {
            name = "Auto Crouch",
            key = Options.AutoCrouchKeybind and Options.AutoCrouchKeybind.Value or "B",
            active = isAutoCrouching
        }
    end
    
    local changed = false
    for k, v in pairs(newCache) do
        if not keybindCache[k] or keybindCache[k].key ~= v.key or keybindCache[k].active ~= v.active then
            changed = true
            break
        end
    end
    
    for k in pairs(keybindCache) do
        if not newCache[k] then
            changed = true
            break
        end
    end
    
    if changed then
        keybindCache = newCache
        return true
    end
    return false
end

local function createKeybindList()
    if keybindListGui then
        keybindListGui:Destroy()
        keybindListGui = nil
    end
    
    if keybindUpdateConnection then
        keybindUpdateConnection:Disconnect()
        keybindUpdateConnection = nil
    end
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "KeybindList"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    if gethui then
        screenGui.Parent = gethui()
    elseif syn and syn.protect_gui then
        syn.protect_gui(screenGui)
        screenGui.Parent = game:GetService("CoreGui")
    else
        screenGui.Parent = game:GetService("CoreGui")
    end
    
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, 200, 0, 100)
    mainFrame.Position = UDim2.new(1, -220, 0.5, -50)
    mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    mainFrame.BorderColor3 = Color3.fromRGB(60, 60, 60)
    mainFrame.BorderSizePixel = 1
    mainFrame.Parent = screenGui
    
    Library:AddToRegistry(mainFrame, {
        BackgroundColor3 = "BackgroundColor"
    })
    
    local accentLine = Instance.new("Frame")
    accentLine.Size = UDim2.new(1, 0, 0, 2)
    accentLine.Position = UDim2.new(0, 0, 0, 0)
    accentLine.BackgroundColor3 = Library.AccentColor
    accentLine.BorderSizePixel = 0
    accentLine.Parent = mainFrame
    
    Library:AddToRegistry(accentLine, {
        BackgroundColor3 = "AccentColor"
    })
    
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, 0, 0, 22)
    titleLabel.Position = UDim2.new(0, 0, 0, 2)
    titleLabel.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    titleLabel.BorderSizePixel = 0
    titleLabel.Text = "Keybinds"
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.Font = Enum.Font.Code
    titleLabel.TextSize = 14
    titleLabel.TextXAlignment = Enum.TextXAlignment.Center
    titleLabel.Parent = mainFrame
    
    Library:AddToRegistry(titleLabel, {
        BackgroundColor3 = "BackgroundColor",
        TextColor3 = "FontColor"
    })
    
    titleLabel.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            keybindDragging = true
            keybindDragStart = input.Position
            keybindStartPos = mainFrame.Position
        end
    end)
    
    titleLabel.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            keybindDragging = false
        end
    end)
    
    game:GetService("UserInputService").InputChanged:Connect(function(input)
        if keybindDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - keybindDragStart
            mainFrame.Position = UDim2.new(
                keybindStartPos.X.Scale,
                keybindStartPos.X.Offset + delta.X,
                keybindStartPos.Y.Scale,
                keybindStartPos.Y.Offset + delta.Y
            )
        end
    end)
    
    local container = Instance.new("Frame")
    container.Name = "Container"
    container.Size = UDim2.new(1, -16, 1, -32)
    container.Position = UDim2.new(0, 8, 0, 28)
    container.BackgroundTransparency = 1
    container.Parent = mainFrame
    
    local listLayout = Instance.new("UIListLayout")
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    listLayout.Padding = UDim.new(0, 6)
    listLayout.Parent = container
    
    keybindListGui = screenGui
    
    local function updateKeybindList()
        if not keybindListEnabled then
            screenGui.Enabled = false
            return
        end
        
        if not updateKeybindCache() then
            return
        end
        
        for _, child in pairs(container:GetChildren()) do
            if child:IsA("Frame") then
                child:Destroy()
            end
        end
        
        for _, keybind in pairs(keybindCache) do
            local keybindFrame = Instance.new("Frame")
            keybindFrame.Size = UDim2.new(1, 0, 0, 18)
            keybindFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
            keybindFrame.BorderSizePixel = 0
            keybindFrame.Parent = container
            
            Library:AddToRegistry(keybindFrame, {
                BackgroundColor3 = "BackgroundColor"
            })
            
            if keybind.active then
                local activeAccent = Instance.new("Frame")
                activeAccent.Size = UDim2.new(0, 2, 1, 0)
                activeAccent.Position = UDim2.new(0, 0, 0, 0)
                activeAccent.BackgroundColor3 = Library.AccentColor
                activeAccent.BorderSizePixel = 0
                activeAccent.Parent = keybindFrame
                
                Library:AddToRegistry(activeAccent, {
                    BackgroundColor3 = "AccentColor"
                })
            end
            
            local nameLabel = Instance.new("TextLabel")
            nameLabel.Size = UDim2.new(0.55, 0, 1, 0)
            nameLabel.Position = UDim2.new(0, 6, 0, 0)
            nameLabel.BackgroundTransparency = 1
            nameLabel.Text = keybind.name
            nameLabel.TextColor3 = keybind.active and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(180, 180, 180)
            nameLabel.Font = Enum.Font.Code
            nameLabel.TextSize = 13
            nameLabel.TextXAlignment = Enum.TextXAlignment.Left
            nameLabel.Parent = keybindFrame
            
            Library:AddToRegistry(nameLabel, {
                TextColor3 = "FontColor"
            })
            
            local keyLabel = Instance.new("TextLabel")
            keyLabel.Size = UDim2.new(0.4, 0, 1, 0)
            keyLabel.Position = UDim2.new(0.55, 0, 0, 0)
            keyLabel.BackgroundTransparency = 1
            keyLabel.Text = "[" .. keybind.key .. "]"
            keyLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
            keyLabel.Font = Enum.Font.Code
            keyLabel.TextSize = 13
            keyLabel.TextXAlignment = Enum.TextXAlignment.Right
            keyLabel.Parent = keybindFrame
            
            Library:AddToRegistry(keyLabel, {
                TextColor3 = "FontColor"
            })
            
            local padding = Instance.new("UIPadding")
            padding.PaddingRight = UDim.new(0, 6)
            padding.Parent = keyLabel
        end
        
        local count = 0
        for _ in pairs(keybindCache) do count = count + 1 end
        local contentHeight = 30 + (count * 24)
        mainFrame.Size = UDim2.new(0, 200, 0, math.max(contentHeight, 50))
        
        screenGui.Enabled = true
    end
    
    keybindUpdateConnection = RunService.RenderStepped:Connect(function()
        if keybindListEnabled then
            updateKeybindList()
        end
    end)
    
    updateKeybindList()
end

local function createCrosshair()
    if crosshairGui then
        crosshairGui:Destroy()
        crosshairGui = nil
    end
    
    if spinConnection then
        spinConnection:Disconnect()
        spinConnection = nil
    end
    
    if rainbowConnection then
        rainbowConnection:Disconnect()
        rainbowConnection = nil
    end
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "CrosshairGui"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    if gethui then
        screenGui.Parent = gethui()
    elseif syn and syn.protect_gui then
        syn.protect_gui(screenGui)
        screenGui.Parent = game:GetService("CoreGui")
    else
        screenGui.Parent = game:GetService("CoreGui")
    end
    
    local crosshairFrame = Instance.new("Frame")
    crosshairFrame.Name = "CrosshairFrame"
    crosshairFrame.Size = UDim2.new(0, 100, 0, 100)
    crosshairFrame.Position = UDim2.new(0.5, crosshairOffsetX, 0.5, crosshairOffsetY)
    crosshairFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    crosshairFrame.BackgroundTransparency = 1
    crosshairFrame.Parent = screenGui
    
    local function createLineWithOutline(size, position, isVertical)
        local container = Instance.new("Frame")
        container.Size = size
        container.Position = position
        container.BackgroundTransparency = 1
        container.Parent = crosshairFrame

        local outline = Instance.new("Frame")
        local outlineOffset = outlineThickness
        if isVertical then
            outline.Size = UDim2.new(1, outlineOffset * 2, 1, outlineOffset * 2)
            outline.Position = UDim2.new(0, -outlineOffset, 0, -outlineOffset)
        else
            outline.Size = UDim2.new(1, outlineOffset * 2, 1, outlineOffset * 2)
            outline.Position = UDim2.new(0, -outlineOffset, 0, -outlineOffset)
        end
        outline.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        outline.BorderSizePixel = 0
        outline.ZIndex = 1
        outline.Name = "Outline"
        outline.Parent = container
        
        local line = Instance.new("Frame")
        line.Size = UDim2.new(1, 0, 1, 0)
        line.Position = UDim2.new(0, 0, 0, 0)
        line.BackgroundColor3 = crosshairColor
        line.BorderSizePixel = 0
        line.ZIndex = 2
        line.Name = "MainLine"
        line.Parent = container
        
        return container
    end

    local halfSize = crosshairSize / 2
    local halfThickness = crosshairThickness / 2
    local halfGap = crosshairGap / 2
    
    createLineWithOutline(
        UDim2.new(0, halfSize - halfGap, 0, crosshairThickness),
        UDim2.new(0.5, -halfSize, 0.5, -halfThickness),
        false
    )
    
    createLineWithOutline(
        UDim2.new(0, halfSize - halfGap, 0, crosshairThickness),
        UDim2.new(0.5, halfGap, 0.5, -halfThickness),
        false
    )
    
    createLineWithOutline(
        UDim2.new(0, crosshairThickness, 0, halfSize - halfGap),
        UDim2.new(0.5, -halfThickness, 0.5, -halfSize),
        true
    )
    
    createLineWithOutline(
        UDim2.new(0, crosshairThickness, 0, halfSize - halfGap),
        UDim2.new(0.5, -halfThickness, 0.5, halfGap),
        true
    )
    
    if centerDotEnabled then
        local dotSize = 4
        local dotContainer = Instance.new("Frame")
        dotContainer.Size = UDim2.new(0, dotSize + (outlineThickness * 2), 0, dotSize + (outlineThickness * 2))
        dotContainer.Position = UDim2.new(0.5, -(dotSize + (outlineThickness * 2))/2, 0.5, -(dotSize + (outlineThickness * 2))/2)
        dotContainer.BackgroundTransparency = 1
        dotContainer.Parent = crosshairFrame
        
        local dotOutline = Instance.new("Frame")
        dotOutline.Size = UDim2.new(0, dotSize + (outlineThickness * 2), 0, dotSize + (outlineThickness * 2))
        dotOutline.Position = UDim2.new(0, 0, 0, 0)
        dotOutline.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        dotOutline.BorderSizePixel = 0
        dotOutline.ZIndex = 1
        dotOutline.Name = "DotOutline"
        dotOutline.Parent = dotContainer
        
        local outlineCorner = Instance.new("UICorner")
        outlineCorner.CornerRadius = UDim.new(1, 0)
        outlineCorner.Parent = dotOutline
        
        local centerDot = Instance.new("Frame")
        centerDot.Size = UDim2.new(0, dotSize, 0, dotSize)
        centerDot.Position = UDim2.new(0, outlineThickness, 0, outlineThickness)
        centerDot.BackgroundColor3 = crosshairColor
        centerDot.BorderSizePixel = 0
        centerDot.ZIndex = 2
        centerDot.Name = "CenterDot"
        centerDot.Parent = dotContainer
        
        local centerCorner = Instance.new("UICorner")
        centerCorner.CornerRadius = UDim.new(1, 0)
        centerCorner.Parent = centerDot
    end
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(0, 200, 0, 20)
    textLabel.Position = UDim2.new(0.5, 0, 0.5, textOffsetY)
    textLabel.AnchorPoint = Vector2.new(0.5, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = crosshairText
    textLabel.TextColor3 = crosshairColor
    textLabel.TextStrokeTransparency = 0
    textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    textLabel.Font = Enum.Font.Code
    textLabel.TextSize = 14
    textLabel.Name = "CrosshairTextLabel"
    textLabel.Parent = screenGui
    
    crosshairGui = screenGui
    
    local rotation = 0
    spinConnection = RunService.RenderStepped:Connect(function(dt)
        if crosshairEnabled then
            rotation = rotation + (crosshairSpinSpeed * dt * 60)
            crosshairFrame.Rotation = rotation
        end
    end)
    
    if rainbowMode then
        rainbowConnection = RunService.RenderStepped:Connect(function()
            if crosshairEnabled and rainbowMode then
                local rainbowColor = getRainbowColor()
                
                local frame = crosshairGui:FindFirstChild("CrosshairFrame")
                if frame then
                    for _, child in pairs(frame:GetDescendants()) do
                        if child.Name == "MainLine" or child.Name == "CenterDot" then
                            child.BackgroundColor3 = rainbowColor
                        end
                    end
                end
                
                local textLabel = crosshairGui:FindFirstChild("CrosshairTextLabel")
                if textLabel then
                    textLabel.TextColor3 = rainbowColor
                end
            end
        end)
    end
end

local function updateCrosshairColor()
    if crosshairGui and not rainbowMode then
        local frame = crosshairGui:FindFirstChild("CrosshairFrame")
        if frame then
            for _, child in pairs(frame:GetDescendants()) do
                if child.Name == "MainLine" or child.Name == "CenterDot" then
                    child.BackgroundColor3 = crosshairColor
                end
            end
        end
        
        local textLabel = crosshairGui:FindFirstChild("CrosshairTextLabel")
        if textLabel then
            textLabel.TextColor3 = crosshairColor
        end
    end
end

local function updateTextOffset()
    if crosshairGui then
        local textLabel = crosshairGui:FindFirstChild("CrosshairTextLabel")
        if textLabel then
            textLabel.Position = UDim2.new(0.5, 0, 0.5, textOffsetY)
        end
    end
end

local function updateCrosshairPosition()
    if crosshairGui then
        local frame = crosshairGui:FindFirstChild("CrosshairFrame")
        if frame then
            frame.Position = UDim2.new(0.5, crosshairOffsetX, 0.5, crosshairOffsetY)
        end
    end
end

VisualsGroup:AddToggle('CrosshairToggle', {
    Text = 'Enable Crosshair',
    Default = false,
    Tooltip = 'Shows a spinning crosshair',
    Callback = function(Value)
        crosshairEnabled = Value
        
        if Value then
            createCrosshair()
        else
            if crosshairGui then
                crosshairGui:Destroy()
                crosshairGui = nil
            end
            if spinConnection then
                spinConnection:Disconnect()
                spinConnection = nil
            end
            if rainbowConnection then
                rainbowConnection:Disconnect()
                rainbowConnection = nil
            end
        end
    end
})

VisualsGroup:AddDivider()
VisualsGroup:AddLabel('Color & Style')

VisualsGroup:AddToggle('RainbowMode', {
    Text = 'Rainbow Mode',
    Default = false,
    Tooltip = 'Cycle through rainbow colors',
    Callback = function(Value)
        rainbowMode = Value
        
        if Value then
            if crosshairEnabled then
                createCrosshair()
            end
        else
            if rainbowConnection then
                rainbowConnection:Disconnect()
                rainbowConnection = nil
            end
            updateCrosshairColor()
        end
    end
})

VisualsGroup:AddSlider('RainbowSpeed', {
    Text = 'Rainbow Speed',
    Default = 2.2,
    Min = 0.1,
    Max = 5,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        rainbowSpeed = Value
    end
})

VisualsGroup:AddLabel('Crosshair Color'):AddColorPicker('CrosshairColor', {
    Default = Color3.fromRGB(255, 255, 255),
    Title = 'Crosshair Color',
    Transparency = 0,
    Callback = function(Value)
        crosshairColor = Value
        if not rainbowMode then
            updateCrosshairColor()
        end
    end
})

VisualsGroup:AddSlider('CrosshairSpeed', {
    Text = 'Spin Speed',
    Default = 3.5,
    Min = 0,
    Max = 20,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        crosshairSpinSpeed = Value
    end
})

VisualsGroup:AddDivider()
VisualsGroup:AddLabel('Size & Spacing')

VisualsGroup:AddSlider('CrosshairSize', {
    Text = 'Crosshair Size',
    Default = 27.8,
    Min = 10,
    Max = 100,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        crosshairSize = Value
        if crosshairEnabled then
            createCrosshair()
        end
    end
})

VisualsGroup:AddSlider('CrosshairThickness', {
    Text = 'Line Thickness',
    Default = 2.3,
    Min = 1,
    Max = 10,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        crosshairThickness = Value
        if crosshairEnabled then
            createCrosshair()
        end
    end
})

VisualsGroup:AddSlider('OutlineThickness', {
    Text = 'Outline Thickness',
    Default = 2,
    Min = 1,
    Max = 6,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        outlineThickness = Value
        if crosshairEnabled then
            createCrosshair()
        end
    end
})

VisualsGroup:AddSlider('CrosshairGap', {
    Text = 'Bar Spacing (Gap)',
    Default = 8.9,
    Min = 0,
    Max = 30,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        crosshairGap = Value
        if crosshairEnabled then
            createCrosshair()
        end
    end
})

VisualsGroup:AddToggle('CenterDotToggle', {
    Text = 'Show Center Dot',
    Default = true,
    Tooltip = 'Toggle center dot visibility',
    Callback = function(Value)
        centerDotEnabled = Value
        if crosshairEnabled then
            createCrosshair()
        end
    end
})

VisualsGroup:AddDivider()
VisualsGroup:AddLabel('Text Settings')

VisualsGroup:AddInput('CrosshairText', {
    Default = 'Reden.Hook',
    Numeric = false,
    Finished = false,
    Text = 'Crosshair Text',
    Tooltip = 'Text displayed under crosshair',
    Placeholder = 'Enter text...',
    Callback = function(Value)
        crosshairText = Value
        
        if crosshairGui then
            local textLabel = crosshairGui:FindFirstChild("CrosshairTextLabel")
            if textLabel then
                textLabel.Text = Value
            end
        end
    end
})

VisualsGroup:AddSlider('TextOffset', {
    Text = 'Name Offset (Y)',
    Default = 20,
    Min = 5,
    Max = 200,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        textOffsetY = Value
        updateTextOffset()
    end
})

VisualsGroup:AddDivider()
VisualsGroup:AddLabel('Position Adjustment')

VisualsGroup:AddSlider('CrosshairOffsetX', {
    Text = 'Crosshair X Position',
    Default = 0,
    Min = -100,
    Max = 100,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        crosshairOffsetX = Value
        updateCrosshairPosition()
    end
})

VisualsGroup:AddSlider('CrosshairOffsetY', {
    Text = 'Crosshair Y Position',
    Default = -29.3,
    Min = -100,
    Max = 100,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        crosshairOffsetY = Value
        updateCrosshairPosition()
    end
})

local EnhancementsGroup = Tabs.Visuals:AddLeftGroupbox('Visual Enhancements')

EnhancementsGroup:AddLabel('ðŸ’¡ Make the game brighter')

EnhancementsGroup:AddToggle('FullbrightToggle', {
    Text = 'Fullbright',
    Default = false,
    Tooltip = 'Removes shadows and makes everything bright',
    Callback = function(Value)
        fullbrightEnabled = Value
        toggleFullbright(Value)
    end
})

EnhancementsGroup:AddToggle('NoFogToggle', {
    Text = 'No Fog',
    Default = false,
    Tooltip = 'Removes fog for better visibility',
    Callback = function(Value)
        toggleNoFog(Value)
    end
})

EnhancementsGroup:AddDivider()
EnhancementsGroup:AddLabel('ðŸŽ¨ Light Customization')

EnhancementsGroup:AddToggle('LightColorToggle', {
    Text = 'Custom Light Color',
    Default = false,
    Tooltip = 'Change the lighting and ambient color',
    Callback = function(Value)
        lightColorEnabled = Value
        changeLightColor(Value)
    end
})

EnhancementsGroup:AddLabel('Light Color'):AddColorPicker('LightColorPicker', {
    Default = Color3.fromRGB(0, 0, 0),
    Title = 'Light Color',
    Transparency = 0,
    Callback = function(Value)
        lightColor = Value
        updateLightColor()
    end
})

local KeybindListGroup = Tabs.Visuals:AddLeftGroupbox('Keybind List')

KeybindListGroup:AddToggle('KeybindListToggle', {
    Text = 'Show Keybind List',
    Default = false,
    Tooltip = 'Display active keybinds on screen',
    Callback = function(Value)
        keybindListEnabled = Value
        if Value then
            createKeybindList()
        elseif keybindListGui then
            keybindListGui.Enabled = false
        end
    end
})

KeybindListGroup:AddToggle('KeybindListAlwaysShow', {
    Text = 'Always Show',
    Default = true,
    Tooltip = 'Show all keybinds or only active ones',
    Callback = function(Value)
        keybindListAlwaysShow = Value
    end
})

local CombatGroup = Tabs.Combat:AddLeftGroupbox('Auto Crouch')

CombatGroup:AddLabel('Press keybind to toggle on/off')

CombatGroup:AddLabel('Keybind'):AddKeyPicker('AutoCrouchKeybind', {
    Default = 'B',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Auto Crouch',
    Callback = function(Value)
        if Value then
            startAutoCrouch()
        else
            stopAutoCrouch()
        end
    end
})

CombatGroup:AddDivider()
CombatGroup:AddLabel('Timing Settings')

CombatGroup:AddSlider('CrouchTime', {
    Text = 'Crouch Time',
    Default = 1,
    Min = 0.1,
    Max = 5,
    Rounding = 1,
    Compact = false,
    Suffix = 's',
    Callback = function(Value)
        crouchTime = Value
    end
})

CombatGroup:AddSlider('BeforeRepeatDelay', {
    Text = 'Before Repeat',
    Default = 0.5,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Suffix = 's',
    Callback = function(Value)
        beforeRepeatDelay = Value
    end
})

CombatGroup:AddDivider()


local StreamGroup = Tabs.StreamProtection:AddLeftGroupbox('Username Spoof')

local spoofedUsername = ""
local usernameEnabled = false

StreamGroup:AddInput('SpoofUsername', {
    Default = '',
    Numeric = false,
    Finished = false,
    Text = 'Spoofed Username',
    Tooltip = 'Enter the fake username to display',
    Placeholder = 'Enter username...',
    Callback = function(Value)
        spoofedUsername = Value
    end
})

StreamGroup:AddToggle('EnableUsernameSpoof', {
    Text = 'Enable Username Spoof',
    Default = false,
    Tooltip = 'Hides your real username',
    Callback = function(Value)
        usernameEnabled = Value
        
        if Value and spoofedUsername ~= "" then
            xpcall(function()
                local G,P,LP=game,game:GetService("Players"),game:GetService("Players").LocalPlayer
                local fake=spoofedUsername
                local vid=LP.UserId
                local vn=LP.Name
                local dn=LP.DisplayName
                local function updateUI(obj)
                    if obj:IsA("TextLabel")or obj:IsA("TextButton")or obj:IsA("TextBox")then
                        if obj.Text:find(vn)or obj.Text:find(dn)then
                            obj.Text=obj.Text:gsub(vn,fake):gsub(dn,fake)
                        end
                        obj:GetPropertyChangedSignal("Text"):Connect(function()
                            obj.Text=obj.Text:gsub(vn,fake):gsub(dn,fake)
                        end)
                    end
                end
                for _,v in G:GetDescendants()do updateUI(v)end
                G.DescendantAdded:Connect(updateUI)
            end,function()end)
        elseif Value and spoofedUsername == "" then
            Options.EnableUsernameSpoof:SetValue(false)
        end
    end
})



Library:SetWatermarkVisibility(false)

local MenuGroup = Tabs.Settings:AddLeftGroupbox('Menu Controls')

MenuGroup:AddLabel('Toggle Menu Key'):AddKeyPicker('MenuKeybind', {
    Default = 'RightShift',
    NoUI = true,
    Text = 'Menu keybind'
})

MenuGroup:AddButton({
    Text = 'Close Menu',
    Func = function()
        if spinConnection then
            spinConnection:Disconnect()
            spinConnection = nil
        end
        if rainbowConnection then
            rainbowConnection:Disconnect()
            rainbowConnection = nil
        end
        if keybindUpdateConnection then
            keybindUpdateConnection:Disconnect()
            keybindUpdateConnection = nil
        end
        stopAutoCrouch()
        Library:Unload()
    end,
    Tooltip = 'Destroy the menu completely'
})

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

ThemeManager:SetFolder('Reden.Hook')
SaveManager:SetFolder('Reden.Hook/configs')

SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:ApplyToTab(Tabs.Settings)

print("========================================")
print("[Reden.Hook] Loaded")
print("[Reden.Hook] Press RightShift to toggle")
print("========================================")
